<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</title>
      <link href="/2019/08/26/HTTP1.0%E3%80%81HTTP1.1%20%E5%92%8C%20HTTP2.0%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/26/HTTP1.0%E3%80%81HTTP1.1%20%E5%92%8C%20HTTP2.0%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>转载自：<a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p><h3 id="一、HTTP的历史"><a href="#一、HTTP的历史" class="headerlink" title="一、HTTP的历史"></a>一、HTTP的历史</h3><p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribgQuEeJaevuN9LRgQ9WR85hRiaVISeia7SDz1aU9hAAgO33XFaJ3FhmhQ/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><h3 id="二、HTTP的基本优化"><a href="#二、HTTP的基本优化" class="headerlink" title="二、HTTP的基本优化"></a>二、HTTP的基本优化</h3><p>影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p><p>带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p><p>延迟：</p><p>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p><p>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><h3 id="三、HTTP1-0和HTTP1-1的一些区别"><a href="#三、HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="三、HTTP1.0和HTTP1.1的一些区别"></a>三、HTTP1.0和HTTP1.1的一些区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><p>缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p>带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p>Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p>长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h3 id="四、HTTPS与HTTP的一些区别"><a href="#四、HTTPS与HTTP的一些区别" class="headerlink" title="四、HTTPS与HTTP的一些区别"></a>四、HTTPS与HTTP的一些区别</h3><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><h3 id="五、SPDY：HTTP1-x的优化"><a href="#五、SPDY：HTTP1-x的优化" class="headerlink" title="五、SPDY：HTTP1.x的优化"></a>五、SPDY：HTTP1.x的优化</h3><p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><p>降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p><p>请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p><p>header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p><p>基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</p><p>服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribjhshzcKo97UNNVIFgpOYZic95drsxo5TaiadPSSmcYhOI7GYAO99W6Sw/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><h3 id="六、HTTP2-0性能惊人"><a href="#六、HTTP2-0性能惊人" class="headerlink" title="六、HTTP2.0性能惊人"></a>六、HTTP2.0性能惊人</h3><p>HTTP/2: the Future of the Internet <a href="https://link.zhihu.com/?target=https://http2.akamai.com/demo" target="_blank" rel="noopener">https://link.zhihu.com/?target=https://http2.akamai.com/demo</a> 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribcBaVkwLTtI3YprKtxYXhyYq7N1N70iaiaUxHFzc05wxQlSFrz3ltzrgw/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><h3 id="七、HTTP2-0：SPDY的升级版"><a href="#七、HTTP2-0：SPDY的升级版" class="headerlink" title="七、HTTP2.0：SPDY的升级版"></a>七、HTTP2.0：SPDY的升级版</h3><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p><p>HTTP2.0和SPDY的区别：</p><p>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</p><p>HTTP2.0 消息头的压缩算法采用 HPACK <a href="http://http2.github.io/http2-spec/compression.html，而非" target="_blank" rel="noopener">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 DEFLATE <a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/DEFLATE</a></p><h3 id="八、HTTP2-0和HTTP1-X相比的新特性"><a href="#八、HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="八、HTTP2.0和HTTP1.X相比的新特性"></a>八、HTTP2.0和HTTP1.X相比的新特性</h3><p>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p>header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</p><h3 id="九、HTTP2-0的升级改造"><a href="#九、HTTP2-0的升级改造" class="headerlink" title="九、HTTP2.0的升级改造"></a>九、HTTP2.0的升级改造</h3><p>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</p><p>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南 <a href="https://www.nginx.com/blog/nginx-1-9-5/。" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/。</a></p><p>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</p><h3 id="十、附注"><a href="#十、附注" class="headerlink" title="十、附注"></a>十、附注</h3><p>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</p><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p><p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p><p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br>具体如图：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><p>服务器推送到底是什么？<br>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p><p>普通的客户端请求过程：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribkZLpDyHlTbAGkEiazqLfjkTSfMgib2UlC0p3Yw0T3iaaHcvLjL22PZWPg/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><p>服务端推送的过程：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribq79os9yK2JmEODZqRVBweS7uMP2WWz4Ij6Z1f9TuiaXANOozhwCWljw/0?wx_fmt=png" alt="浏览器" title="浏览器"></p><p>为什么需要头部压缩？<br>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍</p><p>HTTP2.0多路复用有多好？<br>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p><h3 id="十一、参考"><a href="#十一、参考" class="headerlink" title="十一、参考"></a>十一、参考</h3><p>HTTP/2.0 相比1.0有哪些重大改进？<br>深入研究：HTTP2 的真正性能到底如何<br>HTTP/2 头部压缩技术介绍</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) 为 true 成立吗?</title>
      <link href="/2019/07/28/a-1-a-2-a-3-%E4%B8%BA-true-%E6%88%90%E7%AB%8B%E5%90%97/"/>
      <url>/2019/07/28/a-1-a-2-a-3-%E4%B8%BA-true-%E6%88%90%E7%AB%8B%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p>最近去面试，遇到这么一个面试题, (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) 什么情况为 true?</p><p>我们来列举一下<br><a href="https://yq.aliyun.com/articles/399499" target="_blank" rel="noopener">https://yq.aliyun.com/articles/399499</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何创建一个包含 100 个元素的数组？</title>
      <link href="/2019/07/19/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%20100%20%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9F/"/>
      <url>/2019/07/19/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%20100%20%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>当我最开始知道这个问题的时候，最开始想到的是循环，当然循环是没有问题的，是可以实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for (var i=0; i&lt;99; i++) &#123;</span><br><span class="line">    arr.push(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在不使用循环的前提下，如何创建一个包含 100 个元素的数组？</p><p>有人说 new Array(100)，首先 new Array(100) 创建出来的只是一个 [empty x 100] 的数组。</p><p>那我们来探讨一下其他的方法吧。</p><p>一、使用 split 方法<br>这里需要 101 位，因为 join 的 参数存在于数组每两个元素之间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(101).join(0).split(&apos;&apos;)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;0&apos;.repeat(100).split(&apos;&apos;)</span><br></pre></td></tr></table></figure><p>二、使用 Array.prototype.fill 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(100).fill(0)</span><br></pre></td></tr></table></figure><p>三、使用 Array.from 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(&#123;length: 100&#125;, map((x, index)=&gt;index))</span><br></pre></td></tr></table></figure><p>四、使用 Spread 拓展运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...Array(100)].map((x, index)=&gt;index)</span><br></pre></td></tr></table></figure><p>五、使用 Object.keys()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Array.apply(null, &#123;length:100&#125;))</span><br></pre></td></tr></table></figure><p>六、使用 Array.keys()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = new Array(100).keys()</span><br><span class="line">console.log(Array.from(arr))</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...Array(100).keys()]</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...Array.from(&#123;length:100&#125;).keys()]</span><br></pre></td></tr></table></figure><p>以上！以后遇到其他方法再更新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Native Javscript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[1, 2, 3].map(parseInt) 背后的故事</title>
      <link href="/2019/06/02/%5B1,%202,%203%5D.map(parseInt)%20%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2019/06/02/%5B1,%202,%203%5D.map(parseInt)%20%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>[‘1’, ‘2’, ‘3’].map(parseInt) 算是一道经典面试题，当我第一次看到这个题目的时候，脑海里蹦出的答案是 [1, 2, 3], 但答案却是 [1, NaN, NaN]。</p><p>如果想要理解这个问题，必须要了解两个方法， parseInt 和 map。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h3><p>parseInt 函数可用来解析一个字符串，然后返回一个整数。包含两个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure><ol><li><p>参数 string 是要被解析的值。如果参数不是 string，则使用 tostring 函数将其转化为字符串。</p></li><li><p>参数 radix 是一个介于 2 到 36 的整数，表示解析字符串的基数。基数表示几进制，默认是 10 （十进制）。如果 radix 在这个范围之外，parseInt 的结果为 NaN。</p></li></ol><p>在 radix 值为空 （不传，undefined，或者radix为 0）的情况下，JavaScript 作如下处理：</p><ol><li>如果字符串 string 以 ‘0x’ 或者 ‘0X’ 开头, 则默认基数是16 (16进制)；</li><li>如果字符串 string 以 ‘0’ 开头, 默认基数是8（八进制）或者10（十进制），不同的环境使用的基数不同，因此，最好明确给出 radix 参数的值；</li><li>如果字符串 string 以其它任何值开头，则默认基数是10 (十进制)。</li></ol><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是数组的用法，该方法调用一个函数基于数组的每个元素生成一个新的数组。</p><p>举个🌰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].map((item, index, arr) =&gt; &#123;</span><br><span class="line">  return item * 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回调函数包含三个参数</p><ol><li>item 是正在处理的数组的某个元素；</li><li>index 是正在处理的元素在数组中的索引位置；</li><li>arr 是当前正在处理的数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)</span><br></pre></td></tr></table></figure><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((item ,index) =&gt; &#123;</span><br><span class="line">  parseInt(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>得到的返回值是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0) // 1 基数为 0， 八进制或十进制</span><br><span class="line">parseInt(&apos;2&apos;, 1) // NaN, 1 不在 2-36 之间</span><br><span class="line">parseInt(&apos;3&apos;, 2) // NaN, 3 不是二进制</span><br></pre></td></tr></table></figure><p>所以结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)</span><br><span class="line">// 1, NaN, NaN</span><br></pre></td></tr></table></figure><p>以上～</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>React 如何阻止事件冒泡？</title>
      <link href="/2019/05/28/React-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F/"/>
      <url>/2019/05/28/React-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>废话不多说，先上代码 :)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    document.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;document click&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    document.body.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;body click&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    document.getElementById(&apos;child&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;child click&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    document.getElementById(&apos;parent&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;parent click&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  outClick(e) &#123;</span><br><span class="line">    console.log(&apos;outClick&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClick(e) &#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    console.log(&apos;onclick&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div id=&quot;parent&quot; className=&quot;App&quot; onClick=&#123;this.outClick&#125;&gt;</span><br><span class="line">        &lt;button id=&quot;child&quot; onClick=&#123;this.onClick&#125;&gt;test&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>点击 button 后，这段代码的输出结果是什么呢？</p><p><img src="https://i.loli.net/2019/07/01/5d19741e2dc6d73046.png" alt="浏览器" title="浏览器"></p><p>输出结果透露出两个信息：</p><ol><li>document.body 上的事件在 button 事件之前执行</li><li>stopPropagation 可以同组件上的事件冒泡，但不能阻止事件冒泡到 document</li></ol><p>这是为什么呢？</p><p>React 为了提高性能，利用事件委托把组件上的事件都委托给了 document，所以等 stopPropagation 阻止冒泡时，事件已经传到了 document。</p><p>既然 stopPropagation不可行，那有什么解决方法么？ 当然有啦，浏览器还支持另外一个好东西 e.stopImmediatePropagation()，它不只能阻止冒泡，还能阻止在当前事件触发的元素上，触发其他事件。</p><p>React 中的事件都是合成的，对原生事件进行的封装，但同时也省略了某些特性，其中包括 e.stopImmediatePropagation(）。不过这不能阻止我们使用它， e.nativeEvent 可以访问到原生事件， e.nativeEvent.stopImmediatePropagation() 可以阻止组件上的事件冒泡到 document。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onClick(e) &#123;</span><br><span class="line">  console.log(&apos;onclick&apos;)</span><br><span class="line">  e.stopPropagation()</span><br><span class="line">  e.nativeEvent.stopImmediatePropagation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/01/5d19741e1a3a294951.png" alt="浏览器" title="浏览器"></p><p>以上！</p>]]></content>
      
      
      <categories>
          
          <category> web 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Native ECMAScript modules</title>
      <link href="/2019/05/19/Native-ECMAScript-modules/"/>
      <url>/2019/05/19/Native-ECMAScript-modules/</url>
      
        <content type="html"><![CDATA[<p>JS modules 是从 ES6 开始引入的模块系统。由于历史原因，我们借助 babel 等编译工具才能提前使用这些特性。<br>好消息是，越来越多的主流浏览器开始支持 ES modules。 到目前为止，大部分主流浏览器都已经支持了原生 JavaScript modules，这意味着我们可以不用打包编译就可以使用 JavaScript modules。</p><p><img src="https://i.loli.net/2019/07/01/5d19741e73e7030026.png" alt="浏览器" title="浏览器"></p><h3 id="JS-模块化"><a href="#JS-模块化" class="headerlink" title="JS 模块化"></a>JS 模块化</h3><p>在 JS 发展的历程中，诞生过很多模块化方案，例如 CommonJS, AMD, CMD 等，但没有一个统一的规范。ES6 Modules 的出现，将模块语法统一起来。<br>在 JS modules 中，可以使用 export 和 import 导出导入模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.js</span><br><span class="line">export default function() &#123;</span><br><span class="line">  console.log(&apos;hello world!&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import sayHello from &apos;./hello/js&apos;</span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure><h3 id="JS-modules-和传统-Javascript-的区别"><a href="#JS-modules-和传统-Javascript-的区别" class="headerlink" title="JS modules 和传统 Javascript 的区别"></a>JS modules 和传统 Javascript 的区别</h3><ol><li>默认开启严格模式</li><li>不支持HTML风格的注释 （&lt;!–注释 –&gt;）</li><li>每个模块都有自己的作用域</li><li>import export 仅在 JS modules 中使用，传统脚本不能使用</li></ol><p>如何在浏览器中使用 JS modules 呢？只需在 script 标签上加上 type=”module”, 浏览器就会自动识别 JS modules。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// hello.js</span><br><span class="line">export function sayHello() &#123;</span><br><span class="line">  console.log(&apos;hello world!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// inline</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">import &#123;sayHello&#125; from &apos;./hello.js</span><br><span class="line">sayHello()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注意：.js 后缀不能省略</p><h3 id="import-引入路径支持还不完善"><a href="#import-引入路径支持还不完善" class="headerlink" title="import 引入路径支持还不完善"></a>import 引入路径支持还不完善</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 支持</span><br><span class="line">import &#123;sayHello&#125; from &apos;./hello.js&apos;;</span><br><span class="line">import &#123;sayHello&#125; from &apos;../hello.js&apos;;</span><br><span class="line">import &#123;sayHello&#125; from &apos;/modules/hello.js&apos;;</span><br><span class="line">import &#123;sayHello&#125; from &apos;https://zhihu.com/modules/hello.js&apos;;</span><br><span class="line"></span><br><span class="line">// 不支持</span><br><span class="line">import &#123;sayHello&#125; from &apos;hello.js&apos;;</span><br><span class="line">import &#123;sayHello&#125; from &apos;hello.js&apos;;</span><br><span class="line">import &#123;sayHello&#125; from &apos;modules/hello.js&apos;;</span><br></pre></td></tr></table></figure><h3 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h3><p>nomodule 属性是为兼容不支持 JS modules 的浏览器， 兼容 JS modules 的浏览器不会执行加了 nomodule 属性的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;</span><br><span class="line">&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>对于带有 type=”module” 的 script， 不论是外部脚本还是内联脚本， 浏览器都会异步加载，不会堵塞浏览器渲染。说到异步加载，有两个属性不得不提。defer 和 async。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>scrip 标签加了 defer 或 async 属性，脚本就会异步加载。传统 JS 中，这两个属性只用于外部脚本，不能用于内联脚本。 两者的区别是，defer 会等到整个页面渲染结束才会执行，async 是脚本加载完成就执行。</p><p><img src="https://i.loli.net/2019/07/01/5d19741e58c5833232.png" alt="浏览器" title="浏览器"></p><p>JS modules 默认加载行为类似 defer script，也可以使用 async 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt; &lt;/script&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只要加载完毕，脚本立即执行 --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>浏览器可以预加载，甚至可以预解析，预编译模块及其依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot;&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="加载过程中的差异"><a href="#加载过程中的差异" class="headerlink" title="加载过程中的差异"></a>加载过程中的差异</h3><ol><li>JS modules 只执行一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- main.js 执行多次 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- module.js 只执行一次--&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>JS modules 及其依赖必须处理跨域问题。<br>传统 JS 中引入其他域的脚本文件是没有跨域问题</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过跨域验证，这段脚本才会执行 --&gt;</span><br><span class="line">&lt;script type=&quot;module&quot; src=&quot;https://zhihu.com/modules/hello.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>传统的 script 标签只能在加载外部脚本文件的时候加上 async, 在内联 script 标签加 async 不会生效，但在 JS modules 内联 script 标签上加 async 会生效。</li></ol><h3 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  (async () =&gt; &#123;</span><br><span class="line">    const sayHello = await import(&apos;./hello.js&apos;);</span><br><span class="line">    sayHello()</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>只能使用 import，如果一个模块引入几十个包，不借助构建工具，很难做 tree shaking。</p><p>HTTP2 的 server push 特性，还不能很好的在高度模块化应用使用，web 服务器和浏览器目前也没有针对这种情况进行优化。</p><p>参考：<br><a href="https://jakearchibald.com/2017/es-modules-in-browsers/" target="_blank" rel="noopener">https://jakearchibald.com/2017/es-modules-in-browsers/</a><br><a href="https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module" target="_blank" rel="noopener">https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module</a></p>]]></content>
      
      
      <categories>
          
          <category> web 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Native Javscript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pre 标签文字换行解决方案</title>
      <link href="/2019/02/18/pre-%E6%A0%87%E7%AD%BE%E6%96%87%E5%AD%97%E6%8D%A2%E8%A1%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/02/18/pre-%E6%A0%87%E7%AD%BE%E6%96%87%E5%AD%97%E6%8D%A2%E8%A1%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>大家经常遇到这种情况，当一行文字里包含英文字母或数字时会出现不换行局面，一般用 word-wrap:break-word 强制换行就能解决该问题。</p><p>但有时候后端返回的数据包含 &lt;pre> 标签的时候，用 word-wrap:break-word 换行是没有效果的。</p><p>简单的说就是 &lt;pre> 标签文字无法用 word-wrap:break-word 换行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  pre &#123;</span><br><span class="line">    display: block; </span><br><span class="line">    width: 200px; </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: #ddd;</span><br><span class="line">    word-wrap: break-word;</span><br><span class="line">  &#125;  </span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;hexohexohexohexohexohexohexohexohexohexohexohexohexohexohexo&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ju-da-ren.wang/images/pre.png" alt="pre" title="pre"></p><p>解决方法：用 white-space:pre-line 或者 white-space:pre-wrap 就可以轻松解决。</p>]]></content>
      
      
      <categories>
          
          <category> web 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客是怎样炼成的？</title>
      <link href="/2019/02/18/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%98%AF%E6%80%8E%E6%A0%B7%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%9F/"/>
      <url>/2019/02/18/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%98%AF%E6%80%8E%E6%A0%B7%E7%82%BC%E6%88%90%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>最近忙里偷闲整了个新博客，原来的博客源码找不到了，也没怎么写东西，就重新开发了一个，其实平时不太喜欢写东西，但感觉记录一下平时之所学还是很有益处的。下面介绍一下自己的建站流程。<br>    <span bgcolor="#FF4500">这里</span></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p> Hexo + GitHub</p><p> Hexo 是一款基于 Node.js 的静态博客框架，快速简洁，插件丰富，并且支持 Markdown,开发也很简单，可以生成静态网页托管到 GitHub 或 Heroku 上，我选用的是 GitHub。</p><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><p>可以在阿里云或腾讯云上申请你的个性域名，使用 GitHub 托管网站，不需要备案，因为托管我们网站的服务器在美国，而且国内备案流程比较繁杂，省去了备案流程也节省了时间。</p><h3 id="GitHub-创建个人仓库"><a href="#GitHub-创建个人仓库" class="headerlink" title="GitHub 创建个人仓库"></a>GitHub 创建个人仓库</h3><p>登录 GitHub 账号，然后创建新仓库，仓库名应该为：用户名.github.io，这是固定写法，比如我的仓库名是 summerwang0915.github.io。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>首先安装 Hexo 命令行工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>然后初始化我们的博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><p>为了查看我们的博客雏形，本地启动博客，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>完成后访问 localhost:4000 即可看到我们博客啦。</p><h3 id="自定义博客"><a href="#自定义博客" class="headerlink" title="自定义博客"></a>自定义博客</h3><p>选择一个喜欢的主题，我选择的是 <a href="https://github.com/sabrinaluo/hexo-theme-replica" target="_blank" rel="noopener">hexo-theme-replica</a>。这个主题是 GitHub 风格的，我稍加修改了下，改成了自己喜欢的样子。</p><p>在 _config.yml 文件里修改主题的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-replica</span><br></pre></td></tr></table></figure><p>也可以修改博客的基本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 橘大人的 Blog</span><br><span class="line">subtitle:</span><br><span class="line">description: 写代码要跟写书法一样写一辈子，喵～</span><br></pre></td></tr></table></figure><p>然后可以修改主题的样式和功能，最后得到你想要的博客的样子。</p><h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>链接 GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:summerwang0915/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>分别执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>这三条命令是部署网站的命令：<br>hexo g 是 hexo generate 的缩写，用来生成静态文件（public）。<br>hexo d 是 hexo deploy的缩写，用来将生成的静态文件部署到 GitHub 上。<br>hexo clean 用来清除缓存文件和已生成的静态文件。在某些情况下，如果发现对站点的修改不生效，可能需要该命令。</p><p>部署完成后，略等几秒后，访问网站地址，即 xxxx.github.io，你会发现博客已经在线上能访问了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果你想使用个性化域名，则需要在域名代理厂商那里申请。我申请的是腾讯云的域名。域名申请完毕后，进入代腾讯云管理控制台的域名列表，进行解析。</p><p><img src="https://ju-da-ren.wang/images/yuming.png" alt="域名" title="域名"><br><img src="https://ju-da-ren.wang/images/jiexi.png" alt="域名解析" title="域名解析"></p><p>添加两条解析记录,有的时候访问可能会加上 www，其中 185.199.108.153 是 ping 你的 xxxx.github.io 的获得的ip地址。</p><p>最后在 source 文件夹下创建 CNAME 文件，把域名填进去。推送到 GitHub 上后，CNAME 文件会显示在根目录下。</p><p><img src="https://ju-da-ren.wang/images/cname.png" alt="CNAME" title="CNAME"><br><img src="https://ju-da-ren.wang/images/cname2.png" alt="CNAME" title="CNAME"></p><h4 id="大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"><a href="#大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。" class="headerlink" title="大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"></a>大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。</h4>]]></content>
      
      
      <categories>
          
          <category> web 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
