[{"title":"玩转图片Base64编码","date":"2019-10-10","path":"2019/10/10/玩转图片Base64编码/","text":"转载自：【前端攻略】：玩转图片Base64编码 引言 图片处理在前端工作中可谓占据了很重要的一壁江山。而图片的 base64 编码可能相对一些人而言比较陌生，本文不是从纯技术的角度去讨论图片的 base64 编码。标题略大，不过只是希望通过一些浅显的论述，让你知道什么是图片的 base64 编码，为什么我们要用它，我们如何使用并且方便的使用它，并让你懂得如何去在前端的实际工作中运用它。 什么是 base64 编码? 我不是来讲概念的，直接切入正题，图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址。 这样做有什么意义呢？我们知道，我们所看到的网页上的每一个图片，都是需要消耗一个 http 请求下载而来的（所有才有了 csssprites 技术的应运而生，但是 csssprites 有自身的局限性，下文会提到）。 没错，不管如何，图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，而可以随着 HTML 的下载同时下载到本地那就太好了，而 base64 正好能解决这个问题。 那么图片的 base64 编码长什么样子呢？举个栗子。www.google.com 的首页搜索框右侧的搜索小图标使用的就是base64编码。我们可以看到： 1234//在css里的写法#fkbx-spch, #fkbx-hspch &#123; background: url(data:image/gif;base64,R0lGODlhHAAmAKIHAKqqqsvLy0hISObm5vf394uLiwAAAP///yH5B…EoqQqJKAIBaQOVKHAXr3t7txgBjboSvB8EpLoFZywOAo3LFE5lYs/QW9LT1TRk1V7S2xYJADs=) no-repeat center;&#125; 12//在html代码img标签里的写法&lt;img src=&quot;data:image/gif;base64,R0lGODlhHAAmAKIHAKqqqsvLy0hISObm5vf394uLiwAAAP///yH5B…EoqQqJKAIBaQOVKHAXr3t7txgBjboSvB8EpLoFZywOAo3LFE5lYs/QW9LT1TRk1V7S2xYJADs=&quot;&gt; 上面分别是图片的 base64 编码在 css 里面的写法和在 html 标签里的写法。base64 编码长得就是这个样子。 为什么要使用 Base64 编码？ 那么为什么要使用 base64 传输图片文件？上文也有提及，因为这样可以节省一个 http 请求。图片的 base64 编码可以算是前端优化的一环。效益虽小，但却缺能积少成多。 说到这里，不得不提的是 CssSprites 技术，后者也是为了减少 http 请求，而将页面中许多细小的图片合并为一张大图。那么图片的 base64 编码和 CssSprites 有什么异同，又该如何取舍呢？ 所以，在这里要明确使用 base64 的一个前提，那就是被 base64 编码的图片足够尺寸小。以博客园的 logo 为例： 如图所示，博客园的 Logo 只有 3.27KB，已经很小了，但是如果将其制作转化成 base64 编码，生成的 base64 字符串编码足足有 4406 个,也就是说，图片被编码之后，生成的字符串编码大小一般而言都会比原文件稍大一些。即便 base64 编码能够被 gzip 压缩，压缩率能达到 50% 以上，想象一下，一个元素的 css 样式编写居然超过了 2000个 字符，那对 css 整体的可读性将会造成十分大的影响，代码的冗余使得在此使用 base64 编码将得不偿失。 那么，是不是表示 base64 编码无用武之地呢？不然。当页面中的图片满足以下要求，base64 就能大显生手。 如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新。 那么此时使用 base64 编码传输图片就可谓好钢用在刀刃上，思前想后，符合这个规则的，有一个是我们经常会遇到的，就是页面的背景图 background-image 。在很多地方，我们会制作一个很小的图片大概是几px*几px，然后平铺它页面当背景图。因为是背景图的缘故，所以无法将它放入雪碧图，而它却存在网站的很多页面，这种图片往往只有几十字节，却需要一个 http 请求，十分不值得。那么此时将它转化为 base64 编码，何乐而不为？ 下面是一个只有 50 字节的2*2的的背景图。将其转化成 base64 编码，只有 100 多个字符，相比一个 http 请求，这种转换无疑更值得推崇。 CssSprites与Base64编码 简单陈述一下我对何时这使用这两种优化方法的看法。 使用CssSprites合并为一张大图： 页面具有多种风格，需要换肤功能，可使用CssSprites 网站已经趋于完美，不会再三天两头的改动（例如button大小、颜色等） 使用时无需重复图形内容 没有 Base64 编码成本，降低图片更新的维护难度。（但注意 Sprites 同时修改 css 和图片某些时候可能造成负担） 不会增加 CSS 文件体积 使用base64直接把图片编码成字符串写入CSS文件： 无额外请求 对于极小或者极简单图片 可像单独图片一样使用，比如背景图片重复使用等 没有跨域问题，无需考虑缓存、文件头或者cookies问题 更便捷的将图片转化为Base64编码 将图片转化为 base64 编码有许多工具，例如本文中我所使用的 http://www.pjhome.net/web/html5/encodeDataUrl.htm ，但是很多这些网站是国外网站，经常被墙登陆不了。这里介绍一个更为快捷的方法，就是利用 Chrome 浏览器（我想 FEer 都应该有Chrome 浏览器吧=。=）。 在 chrome 下新建一个窗口，然后把要转化的图片直接拖入浏览器，打开控制台，点 Source，如下图所示，点击图片，右侧就会显示该图片的 base64 编码，是不是很方便。 一些误区Base64 虽有优点，但是缺点也很明显，在使用上存在一些明显的缺陷。 1. 使用 Base64 不代表性能优化是的，使用 Base64 的好处是能够减少一个图片的 HTTP 请求，然而，与之同时付出的代价则是 CSS 文件体积的增大。 而 CSS 文件体积的增大意味着什么呢？意味着 CRP 的阻塞。 CRP（Critical Rendering Path，关键渲染路径）：当浏览器从服务器接收到一个HTML页面的请求时，到屏幕上渲染出来要经过很多个步骤。浏览器完成这一系列的运行，或者说渲染出来我们常常称之为“关键渲染路径”。 通俗而言，就是图片不会导致关键渲染路径的阻塞，而转化为 Base64 的图片大大增加了 CSS 文件的体积，CSS 文件的体积直接影响渲染，导致用户会长时间注视空白屏幕。HTML 和 CSS 会阻塞渲染，而图片不会。 2. 页面解析 CSS 生成的 CSSOM 时间增加Base64 跟 CSS 混在一起，大大增加了浏览器需要解析CSS树的耗时。其实解析CSS树的过程是很快的，一般在几十微妙到几毫秒之间。 CSS 对象模型 (CSSOM)：CSSOM是一个建立在web页面上的 CSS 样式的映射，它和DOM类似，但是只针对CSS而不是HTML。 CSSOM 生成过程： CSSOM 生成过程大致是，解析 HTML ，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表，下载该样式表后根据上述过程生成 CSSOM 树。 这里我们要知道的是，CSSOM 阻止任何东西渲染，（意味着在CSS没处理好之前所有东西都不会展示），而如果CSS文件中混入了Base64，那么（因为文件体积的大幅增长）解析时间会增长到十倍以上。 而且，最重要的是，增加的解析时间全部都在关键渲染路径上。 所以，当我们需要使用到 Base64 技术的时，一定要意识到上述的问题，有取舍的进行使用。"},{"title":"HTTP1.0、HTTP1.1 和 HTTP2.0 的区别","date":"2019-08-26","path":"2019/08/26/HTTP1.0、HTTP1.1 和 HTTP2.0 的区别/","text":"转载自：HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 一、HTTP的历史早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。 二、HTTP的基本优化影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 三、HTTP1.0和HTTP1.1的一些区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 四、HTTPS与HTTP的一些区别HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 五、SPDY：HTTP1.x的优化2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 六、HTTP2.0性能惊人HTTP/2: the Future of the Internet https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。 七、HTTP2.0：SPDY的升级版HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下： HTTP2.0和SPDY的区别： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 DEFLATE http://zh.wikipedia.org/wiki/DEFLATE 八、HTTP2.0和HTTP1.X相比的新特性新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 九、HTTP2.0的升级改造前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南 https://www.nginx.com/blog/nginx-1-9-5/。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 十、附注HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图： 服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下： 普通的客户端请求过程： 服务端推送的过程： 为什么需要头部压缩？假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍 HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 十一、参考HTTP/2.0 相比1.0有哪些重大改进？深入研究：HTTP2 的真正性能到底如何HTTP/2 头部压缩技术介绍"},{"title":"如何创建一个包含 100 个元素的数组？","date":"2019-07-19","path":"2019/07/19/如何创建一个包含 100 个元素的数组？/","text":"当我最开始知道这个问题的时候，最开始想到的是循环，当然循环是没有问题的，是可以实现的。 1234var arr = [];for (var i=0; i&lt;99; i++) &#123; arr.push(0)&#125; 那么在不使用循环的前提下，如何创建一个包含 100 个元素的数组？ 有人说 new Array(100)，首先 new Array(100) 创建出来的只是一个 [empty x 100] 的数组。 那我们来探讨一下其他的方法吧。 一、使用 split 方法这里需要 101 位，因为 join 的 参数存在于数组每两个元素之间 1Array(101).join(0).split(&apos;&apos;) 或者 1&apos;0&apos;.repeat(100).split(&apos;&apos;) 二、使用 Array.prototype.fill 方法 1Array(100).fill(0) 三、使用 Array.from 方法 1Array.from(&#123;length: 100&#125;, map((x, index)=&gt;index)) 四、使用 Spread 拓展运算符 1[...Array(100)].map((x, index)=&gt;index) 五、使用 Object.keys() 1Object.keys(Array.apply(null, &#123;length:100&#125;)) 六、使用 Array.keys() 12let arr = new Array(100).keys()console.log(Array.from(arr)) 或者 1[...Array(100).keys()] 或者 1[...Array.from(&#123;length:100&#125;).keys()] 以上！以后遇到其他方法再更新。"},{"title":"[1, 2, 3].map(parseInt) 背后的故事","date":"2019-06-02","path":"2019/06/02/[1, 2, 3].map(parseInt) 背后的故事/","text":"[‘1’, ‘2’, ‘3’].map(parseInt) 算是一道经典面试题，当我第一次看到这个题目的时候，脑海里蹦出的答案是 [1, 2, 3], 但答案却是 [1, NaN, NaN]。 如果想要理解这个问题，必须要了解两个方法， parseInt 和 map。 parseIntparseInt 函数可用来解析一个字符串，然后返回一个整数。包含两个参数。 1parseInt(string, radix) 参数 string 是要被解析的值。如果参数不是 string，则使用 tostring 函数将其转化为字符串。 参数 radix 是一个介于 2 到 36 的整数，表示解析字符串的基数。基数表示几进制，默认是 10 （十进制）。如果 radix 在这个范围之外，parseInt 的结果为 NaN。 在 radix 值为空 （不传，undefined，或者radix为 0）的情况下，JavaScript 作如下处理： 如果字符串 string 以 ‘0x’ 或者 ‘0X’ 开头, 则默认基数是16 (16进制)； 如果字符串 string 以 ‘0’ 开头, 默认基数是8（八进制）或者10（十进制），不同的环境使用的基数不同，因此，最好明确给出 radix 参数的值； 如果字符串 string 以其它任何值开头，则默认基数是10 (十进制)。 mapmap 是数组的用法，该方法调用一个函数基于数组的每个元素生成一个新的数组。 举个🌰 123[1,2,3].map((item, index, arr) =&gt; &#123; return item * 2&#125;) 回调函数包含三个参数 item 是正在处理的数组的某个元素； index 是正在处理的元素在数组中的索引位置； arr 是当前正在处理的数组。 1[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) 等同于123[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((item ,index) =&gt; &#123; parseInt(item, index)&#125;) 得到的返回值是 123parseInt(&apos;1&apos;, 0) // 1 基数为 0， 八进制或十进制parseInt(&apos;2&apos;, 1) // NaN, 1 不在 2-36 之间parseInt(&apos;3&apos;, 2) // NaN, 3 不是二进制 所以结果是 12[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)// 1, NaN, NaN 以上～"},{"title":"React 如何阻止事件冒泡？","date":"2019-05-28","path":"2019/05/28/React-如何阻止事件冒泡？/","text":"废话不多说，先上代码 :) 1234567891011121314151617181920212223242526272829303132333435363738class App extends Component &#123; componentDidMount() &#123; document.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;document click&apos;) &#125;) document.body.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;body click&apos;) &#125;) document.getElementById(&apos;child&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;child click&apos;) &#125;) document.getElementById(&apos;parent&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;parent click&apos;) &#125;) &#125; outClick(e) &#123; console.log(&apos;outClick&apos;) &#125; onClick(e) &#123; e.stopPropagation() console.log(&apos;onclick&apos;) &#125; render() &#123; return ( &lt;div id=&quot;parent&quot; className=&quot;App&quot; onClick=&#123;this.outClick&#125;&gt; &lt;button id=&quot;child&quot; onClick=&#123;this.onClick&#125;&gt;test&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 点击 button 后，这段代码的输出结果是什么呢？ 输出结果透露出两个信息： document.body 上的事件在 button 事件之前执行 stopPropagation 可以同组件上的事件冒泡，但不能阻止事件冒泡到 document 这是为什么呢？ React 为了提高性能，利用事件委托把组件上的事件都委托给了 document，所以等 stopPropagation 阻止冒泡时，事件已经传到了 document。 既然 stopPropagation不可行，那有什么解决方法么？ 当然有啦，浏览器还支持另外一个好东西 e.stopImmediatePropagation()，它不只能阻止冒泡，还能阻止在当前事件触发的元素上，触发其他事件。 React 中的事件都是合成的，对原生事件进行的封装，但同时也省略了某些特性，其中包括 e.stopImmediatePropagation(）。不过这不能阻止我们使用它， e.nativeEvent 可以访问到原生事件， e.nativeEvent.stopImmediatePropagation() 可以阻止组件上的事件冒泡到 document。 12345onClick(e) &#123; console.log(&apos;onclick&apos;) e.stopPropagation() e.nativeEvent.stopImmediatePropagation()&#125; 以上！"},{"title":"Native ECMAScript modules","date":"2019-05-19","path":"2019/05/19/Native-ECMAScript-modules/","text":"JS modules 是从 ES6 开始引入的模块系统。由于历史原因，我们借助 babel 等编译工具才能提前使用这些特性。好消息是，越来越多的主流浏览器开始支持 ES modules。 到目前为止，大部分主流浏览器都已经支持了原生 JavaScript modules，这意味着我们可以不用打包编译就可以使用 JavaScript modules。 JS 模块化在 JS 发展的历程中，诞生过很多模块化方案，例如 CommonJS, AMD, CMD 等，但没有一个统一的规范。ES6 Modules 的出现，将模块语法统一起来。在 JS modules 中，可以使用 export 和 import 导出导入模块 1234567// hello.jsexport default function() &#123; console.log(&apos;hello world!&apos;)&#125;import sayHello from &apos;./hello/js&apos;sayHello() JS modules 和传统 Javascript 的区别 默认开启严格模式 不支持HTML风格的注释 （&lt;!–注释 –&gt;） 每个模块都有自己的作用域 import export 仅在 JS modules 中使用，传统脚本不能使用 如何在浏览器中使用 JS modules 呢？只需在 script 标签上加上 type=”module”, 浏览器就会自动识别 JS modules。1&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt; 12345678910// hello.jsexport function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125;// inline&lt;script type=&quot;module&quot;&gt;import &#123;sayHello&#125; from &apos;./hello.jssayHello()&lt;/script&gt; 注意：.js 后缀不能省略 import 引入路径支持还不完善12345678910// 支持import &#123;sayHello&#125; from &apos;./hello.js&apos;;import &#123;sayHello&#125; from &apos;../hello.js&apos;;import &#123;sayHello&#125; from &apos;/modules/hello.js&apos;;import &#123;sayHello&#125; from &apos;https://zhihu.com/modules/hello.js&apos;;// 不支持import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;modules/hello.js&apos;; 向后兼容nomodule 属性是为兼容不支持 JS modules 的浏览器， 兼容 JS modules 的浏览器不会执行加了 nomodule 属性的代码。 12&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt; 异步加载对于带有 type=”module” 的 script， 不论是外部脚本还是内联脚本， 浏览器都会异步加载，不会堵塞浏览器渲染。说到异步加载，有两个属性不得不提。defer 和 async。 12&lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; scrip 标签加了 defer 或 async 属性，脚本就会异步加载。传统 JS 中，这两个属性只用于外部脚本，不能用于内联脚本。 两者的区别是，defer 会等到整个页面渲染结束才会执行，async 是脚本加载完成就执行。 JS modules 默认加载行为类似 defer script，也可以使用 async 属性。123456&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt; &lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;&lt;!-- 只要加载完毕，脚本立即执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt; 预加载浏览器可以预加载，甚至可以预解析，预编译模块及其依赖。 12&lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot;&gt;&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 加载过程中的差异 JS modules 只执行一次 1234567&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;!-- main.js 执行多次 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- module.js 只执行一次--&gt; JS modules 及其依赖必须处理跨域问题。传统 JS 中引入其他域的脚本文件是没有跨域问题 12&lt;!-- 通过跨域验证，这段脚本才会执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;https://zhihu.com/modules/hello.js&quot;&gt;&lt;/script&gt; 传统的 script 标签只能在加载外部脚本文件的时候加上 async, 在内联 script 标签加 async 不会生效，但在 JS modules 内联 script 标签上加 async 会生效。 动态导入123456&lt;script type=&quot;module&quot;&gt; (async () =&gt; &#123; const sayHello = await import(&apos;./hello.js&apos;); sayHello() &#125;)();&lt;/script&gt; 局限性只能使用 import，如果一个模块引入几十个包，不借助构建工具，很难做 tree shaking。 HTTP2 的 server push 特性，还不能很好的在高度模块化应用使用，web 服务器和浏览器目前也没有针对这种情况进行优化。 参考：https://jakearchibald.com/2017/es-modules-in-browsers/https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module"},{"title":"pre 标签文字换行解决方案","date":"2019-02-18","path":"2019/02/18/pre-标签文字换行解决方案/","text":"大家经常遇到这种情况，当一行文字里包含英文字母或数字时会出现不换行局面，一般用 word-wrap:break-word 强制换行就能解决该问题。 但有时候后端返回的数据包含 &lt;pre> 标签的时候，用 word-wrap:break-word 换行是没有效果的。 简单的说就是 &lt;pre> 标签文字无法用 word-wrap:break-word 换行的。 1234567891011&lt;style&gt; pre &#123; display: block; width: 200px; height: 100px; background-color: #ddd; word-wrap: break-word; &#125; &lt;/style&gt;&lt;pre&gt;hexohexohexohexohexohexohexohexohexohexohexohexohexohexohexo&lt;/pre&gt; 解决方法：用 white-space:pre-line 或者 white-space:pre-wrap 就可以轻松解决。"},{"title":"我的博客是怎样炼成的？","date":"2019-02-18","path":"2019/02/18/我的博客是怎样炼成的？/","text":"最近忙里偷闲整了个新博客，原来的博客源码找不到了，也没怎么写东西，就重新开发了一个，其实平时不太喜欢写东西，但感觉记录一下平时之所学还是很有益处的。下面介绍一下自己的建站流程。 这里 技术选型 Hexo + GitHub Hexo 是一款基于 Node.js 的静态博客框架，快速简洁，插件丰富，并且支持 Markdown,开发也很简单，可以生成静态网页托管到 GitHub 或 Heroku 上，我选用的是 GitHub。 申请域名可以在阿里云或腾讯云上申请你的个性域名，使用 GitHub 托管网站，不需要备案，因为托管我们网站的服务器在美国，而且国内备案流程比较繁杂，省去了备案流程也节省了时间。 GitHub 创建个人仓库登录 GitHub 账号，然后创建新仓库，仓库名应该为：用户名.github.io，这是固定写法，比如我的仓库名是 summerwang0915.github.io。 安装 Hexo首先安装 Hexo 命令行工具 1$ npm install hexo-cli -g 然后初始化我们的博客 1$ hexo init blog 为了查看我们的博客雏形，本地启动博客， 123$ cd blog$ npm install$ hexo server 完成后访问 localhost:4000 即可看到我们博客啦。 自定义博客选择一个喜欢的主题，我选择的是 hexo-theme-replica。这个主题是 GitHub 风格的，我稍加修改了下，改成了自己喜欢的样子。 在 _config.yml 文件里修改主题的名字 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-replica 也可以修改博客的基本信息 1234# Sitetitle: 橘大人的 Blogsubtitle:description: 写代码要跟写书法一样写一辈子，喵～ 然后可以修改主题的样式和功能，最后得到你想要的博客的样子。 部署博客链接 GitHub 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:summerwang0915/blog.git branch: master 分别执行 123$ hexo clean$ hexo g$ hexo d 这三条命令是部署网站的命令：hexo g 是 hexo generate 的缩写，用来生成静态文件（public）。hexo d 是 hexo deploy的缩写，用来将生成的静态文件部署到 GitHub 上。hexo clean 用来清除缓存文件和已生成的静态文件。在某些情况下，如果发现对站点的修改不生效，可能需要该命令。 部署完成后，略等几秒后，访问网站地址，即 xxxx.github.io，你会发现博客已经在线上能访问了。 绑定域名如果你想使用个性化域名，则需要在域名代理厂商那里申请。我申请的是腾讯云的域名。域名申请完毕后，进入代腾讯云管理控制台的域名列表，进行解析。 添加两条解析记录,有的时候访问可能会加上 www，其中 185.199.108.153 是 ping 你的 xxxx.github.io 的获得的ip地址。 最后在 source 文件夹下创建 CNAME 文件，把域名填进去。推送到 GitHub 上后，CNAME 文件会显示在根目录下。 大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"}]