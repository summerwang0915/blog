[{"title":"[1, 2, 3].map(parseInt) 背后的故事","date":"2019-06-02","path":"2019/06/02/map-parseIn/","text":"[‘1’, ‘2’, ‘3’].map(parseInt) 算是一道经典面试题，当我第一次看到这个题目的时候，脑海里蹦出的答案是 [1, 2, 3], 但答案却是 [1, NaN, NaN]。 如果想要理解这个问题，必须要了解两个方法， parseInt 和 map。 parseIntparseInt 函数可用来解析一个字符串，然后返回一个整数。包含两个参数。 1parseInt(string, radix) 参数 string 是要被解析的值。如果参数不是 string，则使用 tostring 函数将其转化为字符串。 参数 radix 是一个介于 2 到 36 的整数，表示解析字符串的基数。基数表示几进制，默认是 10 （十进制）。如果 radix 在这个范围之外，parseInt 的结果为 NaN。 在 radix 值为空 （不传，undefined，或者radix为 0）的情况下，JavaScript 作如下处理： 如果字符串 string 以 ‘0x’ 或者 ‘0X’ 开头, 则默认基数是16 (16进制)； 如果字符串 string 以 ‘0’ 开头, 默认基数是8（八进制）或者10（十进制），不同的环境使用的基数不同，因此，最好明确给出 radix 参数的值； 如果字符串 string 以其它任何值开头，则默认基数是10 (十进制)。 mapmap 是数组的用法，该方法调用一个函数基于数组的每个元素生成一个新的数组。 举个🌰 123[1,2,3].map((item, index, arr) =&gt; &#123; return item * 2&#125;) 回调函数包含三个参数 item 是正在处理的数组的某个元素； index 是正在处理的元素在数组中的索引位置； arr 是当前正在处理的数组。 1[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) 等同于123[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((item ,index) =&gt; &#123; parseInt(item, index)&#125;) 得到的返回值是 123parseInt(&apos;1&apos;, 0) // 1 基数为 0， 八进制或十进制parseInt(&apos;2&apos;, 1) // NaN, 1 不在 2-36 之间parseInt(&apos;3&apos;, 2) // NaN, 3 不是二进制 所以结果是 12[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)// 1, NaN, NaN 以上～"},{"title":"React 如何阻止事件冒泡？","date":"2019-05-28","path":"2019/05/28/React-如何阻止事件冒泡？/","text":"废话不多说，先上代码 :) 1234567891011121314151617181920212223242526272829303132333435363738class App extends Component &#123; componentDidMount() &#123; document.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;document click&apos;) &#125;) document.body.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;body click&apos;) &#125;) document.getElementById(&apos;child&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;child click&apos;) &#125;) document.getElementById(&apos;parent&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;parent click&apos;) &#125;) &#125; outClick(e) &#123; console.log(&apos;outClick&apos;) &#125; onClick(e) &#123; e.stopPropagation() console.log(&apos;onclick&apos;) &#125; render() &#123; return ( &lt;div id=&quot;parent&quot; className=&quot;App&quot; onClick=&#123;this.outClick&#125;&gt; &lt;button id=&quot;child&quot; onClick=&#123;this.onClick&#125;&gt;test&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 点击 button 后，这段代码的输出结果是什么呢？ 输出结果透露出两个信息： document.body 上的事件在 button 事件之前执行 stopPropagation 可以同组件上的事件冒泡，但不能阻止事件冒泡到 document 这是为什么呢？ React 为了提高性能，利用事件委托把组件上的事件都委托给了 document，所以等 stopPropagation 阻止冒泡时，事件已经传到了 document。 既然 stopPropagation不可行，那有什么解决方法么？ 当然有啦，浏览器还支持另外一个好东西 e.stopImmediatePropagation()，它不只能阻止冒泡，还能阻止在当前事件触发的元素上，触发其他事件。 React 中的事件都是合成的，对原生事件进行的封装，但同时也省略了某些特性，其中包括 e.stopImmediatePropagation(）。不过这不能阻止我们使用它， e.nativeEvent 可以访问到原生事件， e.nativeEvent.stopImmediatePropagation() 可以阻止组件上的事件冒泡到 document。 12345onClick(e) &#123; console.log(&apos;onclick&apos;) e.stopPropagation() e.nativeEvent.stopImmediatePropagation()&#125; 以上！"},{"title":"Native ECMAScript modules","date":"2019-05-19","path":"2019/05/19/Native-ECMAScript-modules/","text":"JS modules 是从 ES6 开始引入的模块系统。由于历史原因，我们借助 babel 等编译工具才能提前使用这些特性。好消息是，越来越多的主流浏览器开始支持 ES modules。 到目前为止，大部分主流浏览器都已经支持了原生 JavaScript modules，这意味着我们可以不用打包编译就可以使用 JavaScript modules。 JS 模块化在 JS 发展的历程中，诞生过很多模块化方案，例如 CommonJS, AMD, CMD 等，但没有一个统一的规范。ES6 Modules 的出现，将模块语法统一起来。在 JS modules 中，可以使用 export 和 import 导出导入模块 1234567// hello.jsexport default function() &#123; console.log(&apos;hello world!&apos;)&#125;import sayHello from &apos;./hello/js&apos;sayHello() JS modules 和传统 Javascript 的区别 默认开启严格模式 不支持HTML风格的注释 （&lt;!–注释 –&gt;） 每个模块都有自己的作用域 import export 仅在 JS modules 中使用，传统脚本不能使用 如何在浏览器中使用 JS modules 呢？只需在 script 标签上加上 type=”module”, 浏览器就会自动识别 JS modules。1&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt; 12345678910// hello.jsexport function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125;// inline&lt;script type=&quot;module&quot;&gt;import &#123;sayHello&#125; from &apos;./hello.jssayHello()&lt;/script&gt; 注意：.js 后缀不能省略 import 引入路径支持还不完善12345678910// 支持import &#123;sayHello&#125; from &apos;./hello.js&apos;;import &#123;sayHello&#125; from &apos;../hello.js&apos;;import &#123;sayHello&#125; from &apos;/modules/hello.js&apos;;import &#123;sayHello&#125; from &apos;https://zhihu.com/modules/hello.js&apos;;// 不支持import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;modules/hello.js&apos;; 向后兼容nomodule 属性是为兼容不支持 JS modules 的浏览器， 兼容 JS modules 的浏览器不会执行加了 nomodule 属性的代码。 12&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt; 异步加载对于带有 type=”module” 的 script， 不论是外部脚本还是内联脚本， 浏览器都会异步加载，不会堵塞浏览器渲染。说到异步加载，有两个属性不得不提。defer 和 async。 12&lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; scrip 标签加了 defer 或 async 属性，脚本就会异步加载。传统 JS 中，这两个属性只用于外部脚本，不能用于内联脚本。 两者的区别是，defer 会等到整个页面渲染结束才会执行，async 是脚本加载完成就执行。 JS modules 默认加载行为类似 defer script，也可以使用 async 属性。123456&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt; &lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;&lt;!-- 只要加载完毕，脚本立即执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt; 预加载浏览器可以预加载，甚至可以预解析，预编译模块及其依赖。 12&lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot;&gt;&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 加载过程中的差异 JS modules 只执行一次 1234567&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;!-- main.js 执行多次 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- module.js 只执行一次--&gt; JS modules 及其依赖必须处理跨域问题。传统 JS 中引入其他域的脚本文件是没有跨域问题 12&lt;!-- 通过跨域验证，这段脚本才会执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;https://zhihu.com/modules/hello.js&quot;&gt;&lt;/script&gt; 传统的 script 标签只能在加载外部脚本文件的时候加上 async, 在内联 script 标签加 async 不会生效，但在 JS modules 内联 script 标签上加 async 会生效。 动态导入123456&lt;script type=&quot;module&quot;&gt; (async () =&gt; &#123; const sayHello = await import(&apos;./hello.js&apos;); sayHello() &#125;)();&lt;/script&gt; 局限性只能使用 import，如果一个模块引入几十个包，不借助构建工具，很难做 tree shaking。 HTTP2 的 server push 特性，还不能很好的在高度模块化应用使用，web 服务器和浏览器目前也没有针对这种情况进行优化。 参考：https://jakearchibald.com/2017/es-modules-in-browsers/https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module"},{"title":"pre 标签文字换行解决方案","date":"2019-02-18","path":"2019/02/18/pre-标签文字换行解决方案/","text":"大家经常遇到这种情况，当一行文字里包含英文字母或数字时会出现不换行局面，一般用 word-wrap:break-word 强制换行就能解决该问题。 但有时候后端返回的数据包含 &lt;pre> 标签的时候，用 word-wrap:break-word 换行是没有效果的。 简单的说就是 &lt;pre> 标签文字无法用 word-wrap:break-word 换行的。 1234567891011&lt;style&gt; pre &#123; display: block; width: 200px; height: 100px; background-color: #ddd; word-wrap: break-word; &#125; &lt;/style&gt;&lt;pre&gt;hexohexohexohexohexohexohexohexohexohexohexohexohexohexohexo&lt;/pre&gt; 解决方法：用 white-space:pre-line 或者 white-space:pre-wrap 就可以轻松解决。"},{"title":"我的博客是怎样炼成的？","date":"2019-02-18","path":"2019/02/18/我的博客是怎样炼成的？/","text":"最近忙里偷闲整了个新博客，原来的博客源码找不到了，也没怎么写东西，就重新开发了一个，其实平时不太喜欢写东西，但感觉记录一下平时之所学还是很有益处的。下面介绍一下自己的建站流程。 技术选型 Hexo + GitHub Hexo 是一款基于 Node.js 的静态博客框架，快速简洁，插件丰富，并且支持 Markdown,开发也很简单，可以生成静态网页托管到 GitHub 或 Heroku 上，我选用的是 GitHub。 申请域名可以在阿里云或腾讯云上申请你的个性域名，使用 GitHub 托管网站，不需要备案，因为托管我们网站的服务器在美国，而且国内备案流程比较繁杂，省去了备案流程也节省了时间。 GitHub 创建个人仓库登录 GitHub 账号，然后创建新仓库，仓库名应该为：用户名.github.io，这是固定写法，比如我的仓库名是 summerwang0915.github.io。 安装 Hexo首先安装 Hexo 命令行工具 1$ npm install hexo-cli -g 然后初始化我们的博客 1$ hexo init blog 为了查看我们的博客雏形，本地启动博客， 123$ cd blog$ npm install$ hexo server 完成后访问 localhost:4000 即可看到我们博客啦。 自定义博客选择一个喜欢的主题，我选择的是 hexo-theme-replica。这个主题是 GitHub 风格的，我稍加修改了下，改成了自己喜欢的样子。 在 _config.yml 文件里修改主题的名字 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-replica 也可以修改博客的基本信息 1234# Sitetitle: 橘大人的 Blogsubtitle:description: 写代码要跟写书法一样写一辈子，喵～ 然后可以修改主题的样式和功能，最后得到你想要的博客的样子。 部署博客链接 GitHub 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:summerwang0915/blog.git branch: master 分别执行 123$ hexo clean$ hexo g$ hexo d 这三条命令是部署网站的命令：hexo g 是 hexo generate 的缩写，用来生成静态文件（public）。hexo d 是 hexo deploy的缩写，用来将生成的静态文件部署到 GitHub 上。hexo clean 用来清除缓存文件和已生成的静态文件。在某些情况下，如果发现对站点的修改不生效，可能需要该命令。 部署完成后，略等几秒后，访问网站地址，即 xxxx.github.io，你会发现博客已经在线上能访问了。 绑定域名如果你想使用个性化域名，则需要在域名代理厂商那里申请。我申请的是腾讯云的域名。域名申请完毕后，进入代腾讯云管理控制台的域名列表，进行解析。 添加两条解析记录,有的时候访问可能会加上 www，其中 185.199.108.153 是 ping 你的 xxxx.github.io 的获得的ip地址。 最后在 source 文件夹下创建 CNAME 文件，把域名填进去。推送到 GitHub 上后，CNAME 文件会显示在根目录下。 大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"}]