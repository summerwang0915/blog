[{"title":"Native ECMAScript modules","date":"2019-05-19","path":"2019/05/19/Native-ECMAScript-modules/","text":"JS modules 是从 ES6 开始引入的模块系统。由于历史原因，我们借助 babel 等编译工具才能提前使用这些特性。好消息是，越来越多的主流浏览器开始支持 ES modules。 到目前为止，大部分主流浏览器都已经支持了原生 JavaScript modules，这意味着我们可以不用打包编译就可以使用 JavaScript modules。 JS 模块化在 JS 发展的历程中，诞生过很多模块化方案，例如 CommonJS, AMD, CMD 等，但没有一个统一的规范。ES6 Modules 的出现，将模块语法统一起来。在 JS modules 中，可以使用 export 和 import 导出导入模块 1234567// hello.jsexport default function() &#123; console.log(&apos;hello world!&apos;)&#125;import sayHello from &apos;./hello/js&apos;sayHello() JS modules 和传统 Javascript 的区别 默认开启严格模式 不支持HTML风格的注释 （&lt;!–注释 –&gt;） 每个模块都有自己的作用域 import export 仅在 JS modules 中使用，传统脚本不能使用 如何在浏览器中使用 JS modules 呢？只需在 script 标签上加上 type=”module”, 浏览器就会自动识别 JS modules。1&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt; 12345678910// hello.jsexport function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125;// inline&lt;script type=&quot;module&quot;&gt;import &#123;sayHello&#125; from &apos;./hello.jssayHello()&lt;/script&gt; 注意：.js 后缀不能省略 import 引入路径支持还不完善12345678910// 支持import &#123;sayHello&#125; from &apos;./hello.js&apos;;import &#123;sayHello&#125; from &apos;../hello.js&apos;;import &#123;sayHello&#125; from &apos;/modules/hello.js&apos;;import &#123;sayHello&#125; from &apos;https://zhihu.com/modules/hello.js&apos;;// 不支持import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;modules/hello.js&apos;; 向后兼容nomodule 属性是为兼容不支持 JS modules 的浏览器， 兼容 JS modules 的浏览器不会执行加了 nomodule 属性的代码。 12&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt; 异步加载对于带有 type=”module” 的 script， 不论是外部脚本还是内联脚本， 浏览器都会异步加载，不会堵塞浏览器渲染。说到异步加载，有两个属性不得不提。defer 和 async。 12&lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; scrip 标签加了 defer 或 async 属性，脚本就会异步加载。传统 JS 中，这两个属性只用于外部脚本，不能用于内联脚本。 两者的区别是，defer 会等到整个页面渲染结束才会执行，async 是脚本加载完成就执行。 JS modules 默认加载行为类似 defer script，也可以使用 async 属性。123456&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt; &lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;&lt;!-- 只要加载完毕，脚本立即执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt; 预加载浏览器可以预加载，甚至可以预解析，预编译模块及其依赖。 12&lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot;&gt;&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 加载过程中的差异 JS modules 只执行一次 1234567&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;!-- main.js 执行多次 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- module.js 只执行一次--&gt; JS modules 及其依赖必须处理跨域问题。传统 JS 中引入其他域的脚本文件是没有跨域问题 12&lt;!-- 通过跨域验证，这段脚本才会执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;https://zhihu.com/modules/hello.js&quot;&gt;&lt;/script&gt; 传统的 script 标签只能在加载外部脚本文件的时候加上 async, 在内联 script 标签加 async 不会生效，但在 JS modules 内联 script 标签上加 async 会生效。 动态导入123456&lt;script type=&quot;module&quot;&gt; (async () =&gt; &#123; const sayHello = await import(&apos;./hello.js&apos;); sayHello() &#125;)();&lt;/script&gt; 局限性只能使用 import，如果一个模块引入几十个包，不借助构建工具，很难做 tree shaking。 HTTP2 的 server push 特性，还不能很好的在高度模块化应用使用，web 服务器和浏览器目前也没有针对这种情况进行优化。 参考：https://jakearchibald.com/2017/es-modules-in-browsers/https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module"},{"title":"pre 标签文字换行解决方案","date":"2019-02-18","path":"2019/02/18/pre-标签文字换行解决方案/","text":"大家经常遇到这种情况，当一行文字里包含英文字母或数字时会出现不换行局面，一般用 word-wrap:break-word 强制换行就能解决该问题。 但有时候后端返回的数据包含 &lt;pre> 标签的时候，用 word-wrap:break-word 换行是没有效果的。 简单的说就是 &lt;pre> 标签文字无法用 word-wrap:break-word 换行的。 1234567891011&lt;style&gt; pre &#123; display: block; width: 200px; height: 100px; background-color: #ddd; word-wrap: break-word; &#125; &lt;/style&gt;&lt;pre&gt;hexohexohexohexohexohexohexohexohexohexohexohexohexohexohexo&lt;/pre&gt; 解决方法：用 white-space:pre-line 或者 white-space:pre-wrap 就可以轻松解决。"},{"title":"我的博客是怎样炼成的？","date":"2019-02-18","path":"2019/02/18/我的博客是怎样炼成的？/","text":"最近忙里偷闲整了个新博客，原来的博客源码找不到了，也没怎么写东西，就重新开发了一个，其实平时不太喜欢写东西，但感觉记录一下平时之所学还是很有益处的。下面介绍一下自己的建站流程。 技术选型 Hexo + GitHub Hexo 是一款基于 Node.js 的静态博客框架，快速简洁，插件丰富，并且支持 Markdown,开发也很简单，可以生成静态网页托管到 GitHub 或 Heroku 上，我选用的是 GitHub。 申请域名可以在阿里云或腾讯云上申请你的个性域名，使用 GitHub 托管网站，不需要备案，因为托管我们网站的服务器在美国，而且国内备案流程比较繁杂，省去了备案流程也节省了时间。 GitHub 创建个人仓库登录 GitHub 账号，然后创建新仓库，仓库名应该为：用户名.github.io，这是固定写法，比如我的仓库名是 summerwang0915.github.io。 安装 Hexo首先安装 Hexo 命令行工具 1$ npm install hexo-cli -g 然后初始化我们的博客 1$ hexo init blog 为了查看我们的博客雏形，本地启动博客， 123$ cd blog$ npm install$ hexo server 完成后访问 localhost:4000 即可看到我们博客啦。 自定义博客选择一个喜欢的主题，我选择的是 hexo-theme-replica。这个主题是 GitHub 风格的，我稍加修改了下，改成了自己喜欢的样子。 在 _config.yml 文件里修改主题的名字 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-replica 也可以修改博客的基本信息 1234# Sitetitle: 橘大人的 Blogsubtitle:description: 写代码要跟写书法一样写一辈子，喵～ 然后可以修改主题的样式和功能，最后得到你想要的博客的样子。 部署博客链接 GitHub 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:summerwang0915/blog.git branch: master 分别执行 123$ hexo clean$ hexo g$ hexo d 这三条命令是部署网站的命令：hexo g 是 hexo generate 的缩写，用来生成静态文件（public）。hexo d 是 hexo deploy的缩写，用来将生成的静态文件部署到 GitHub 上。hexo clean 用来清除缓存文件和已生成的静态文件。在某些情况下，如果发现对站点的修改不生效，可能需要该命令。 部署完成后，略等几秒后，访问网站地址，即 xxxx.github.io，你会发现博客已经在线上能访问了。 绑定域名如果你想使用个性化域名，则需要在域名代理厂商那里申请。我申请的是腾讯云的域名。域名申请完毕后，进入代腾讯云管理控制台的域名列表，进行解析。 添加两条解析记录,有的时候访问可能会加上 www，其中 185.199.108.153 是 ping 你的 xxxx.github.io 的获得的ip地址。 最后在 source 文件夹下创建 CNAME 文件，把域名填进去。推送到 GitHub 上后，CNAME 文件会显示在根目录下。 大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"}]