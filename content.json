[{"title":"HTTP1.0、HTTP1.1 和 HTTP2.0 的区别","date":"2019-08-26","path":"2019/08/26/HTTP1.0、HTTP1.1 和 HTTP2.0 的区别/","text":"转载自：HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 一、HTTP的历史早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。 二、HTTP的基本优化影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 三、HTTP1.0和HTTP1.1的一些区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 四、HTTPS与HTTP的一些区别HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 五、SPDY：HTTP1.x的优化2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 六、HTTP2.0性能惊人HTTP/2: the Future of the Internet https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。 七、HTTP2.0：SPDY的升级版HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下： HTTP2.0和SPDY的区别： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 DEFLATE http://zh.wikipedia.org/wiki/DEFLATE 八、HTTP2.0和HTTP1.X相比的新特性新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 九、HTTP2.0的升级改造前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南 https://www.nginx.com/blog/nginx-1-9-5/。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 十、附注HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图： 服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下： 普通的客户端请求过程： 服务端推送的过程： 为什么需要头部压缩？假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍 HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 十一、参考HTTP/2.0 相比1.0有哪些重大改进？深入研究：HTTP2 的真正性能到底如何HTTP/2 头部压缩技术介绍"},{"title":"(a== 1 && a ==2 && a==3) 为 true 成立吗?","date":"2019-07-28","path":"2019/07/28/a-1-a-2-a-3-为-true-成立吗/","text":"最近去面试，遇到这么一个面试题, (a== 1 &amp;&amp; a ==2 &amp;&amp; a==3) 什么情况为 true? 我们来列举一下https://yq.aliyun.com/articles/399499"},{"title":"如何创建一个包含 100 个元素的数组？","date":"2019-07-19","path":"2019/07/19/如何创建一个包含 100 个元素的数组？/","text":"当我最开始知道这个问题的时候，最开始想到的是循环，当然循环是没有问题的，是可以实现的。 1234var arr = [];for (var i=0; i&lt;99; i++) &#123; arr.push(0)&#125; 那么在不使用循环的前提下，如何创建一个包含 100 个元素的数组？ 有人说 new Array(100)，首先 new Array(100) 创建出来的只是一个 [empty x 100] 的数组。 那我们来探讨一下其他的方法吧。 一、使用 split 方法这里需要 101 位，因为 join 的 参数存在于数组每两个元素之间 1Array(101).join(0).split(&apos;&apos;) 或者 1&apos;0&apos;.repeat(100).split(&apos;&apos;) 二、使用 Array.prototype.fill 方法 1Array(100).fill(0) 三、使用 Array.from 方法 1Array.from(&#123;length: 100&#125;, map((x, index)=&gt;index)) 四、使用 Spread 拓展运算符 1[...Array(100)].map((x, index)=&gt;index) 五、使用 Object.keys() 1Object.keys(Array.apply(null, &#123;length:100&#125;)) 六、使用 Array.keys() 12let arr = new Array(100).keys()console.log(Array.from(arr)) 或者 1[...Array(100).keys()] 或者 1[...Array.from(&#123;length:100&#125;).keys()] 以上！以后遇到其他方法再更新。"},{"title":"[1, 2, 3].map(parseInt) 背后的故事","date":"2019-06-02","path":"2019/06/02/[1, 2, 3].map(parseInt) 背后的故事/","text":"[‘1’, ‘2’, ‘3’].map(parseInt) 算是一道经典面试题，当我第一次看到这个题目的时候，脑海里蹦出的答案是 [1, 2, 3], 但答案却是 [1, NaN, NaN]。 如果想要理解这个问题，必须要了解两个方法， parseInt 和 map。 parseIntparseInt 函数可用来解析一个字符串，然后返回一个整数。包含两个参数。 1parseInt(string, radix) 参数 string 是要被解析的值。如果参数不是 string，则使用 tostring 函数将其转化为字符串。 参数 radix 是一个介于 2 到 36 的整数，表示解析字符串的基数。基数表示几进制，默认是 10 （十进制）。如果 radix 在这个范围之外，parseInt 的结果为 NaN。 在 radix 值为空 （不传，undefined，或者radix为 0）的情况下，JavaScript 作如下处理： 如果字符串 string 以 ‘0x’ 或者 ‘0X’ 开头, 则默认基数是16 (16进制)； 如果字符串 string 以 ‘0’ 开头, 默认基数是8（八进制）或者10（十进制），不同的环境使用的基数不同，因此，最好明确给出 radix 参数的值； 如果字符串 string 以其它任何值开头，则默认基数是10 (十进制)。 mapmap 是数组的用法，该方法调用一个函数基于数组的每个元素生成一个新的数组。 举个🌰 123[1,2,3].map((item, index, arr) =&gt; &#123; return item * 2&#125;) 回调函数包含三个参数 item 是正在处理的数组的某个元素； index 是正在处理的元素在数组中的索引位置； arr 是当前正在处理的数组。 1[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt) 等同于123[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map((item ,index) =&gt; &#123; parseInt(item, index)&#125;) 得到的返回值是 123parseInt(&apos;1&apos;, 0) // 1 基数为 0， 八进制或十进制parseInt(&apos;2&apos;, 1) // NaN, 1 不在 2-36 之间parseInt(&apos;3&apos;, 2) // NaN, 3 不是二进制 所以结果是 12[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt)// 1, NaN, NaN 以上～"},{"title":"React 如何阻止事件冒泡？","date":"2019-05-28","path":"2019/05/28/React-如何阻止事件冒泡？/","text":"废话不多说，先上代码 :) 1234567891011121314151617181920212223242526272829303132333435363738class App extends Component &#123; componentDidMount() &#123; document.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;document click&apos;) &#125;) document.body.addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;body click&apos;) &#125;) document.getElementById(&apos;child&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;child click&apos;) &#125;) document.getElementById(&apos;parent&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; console.log(&apos;parent click&apos;) &#125;) &#125; outClick(e) &#123; console.log(&apos;outClick&apos;) &#125; onClick(e) &#123; e.stopPropagation() console.log(&apos;onclick&apos;) &#125; render() &#123; return ( &lt;div id=&quot;parent&quot; className=&quot;App&quot; onClick=&#123;this.outClick&#125;&gt; &lt;button id=&quot;child&quot; onClick=&#123;this.onClick&#125;&gt;test&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 点击 button 后，这段代码的输出结果是什么呢？ 输出结果透露出两个信息： document.body 上的事件在 button 事件之前执行 stopPropagation 可以同组件上的事件冒泡，但不能阻止事件冒泡到 document 这是为什么呢？ React 为了提高性能，利用事件委托把组件上的事件都委托给了 document，所以等 stopPropagation 阻止冒泡时，事件已经传到了 document。 既然 stopPropagation不可行，那有什么解决方法么？ 当然有啦，浏览器还支持另外一个好东西 e.stopImmediatePropagation()，它不只能阻止冒泡，还能阻止在当前事件触发的元素上，触发其他事件。 React 中的事件都是合成的，对原生事件进行的封装，但同时也省略了某些特性，其中包括 e.stopImmediatePropagation(）。不过这不能阻止我们使用它， e.nativeEvent 可以访问到原生事件， e.nativeEvent.stopImmediatePropagation() 可以阻止组件上的事件冒泡到 document。 12345onClick(e) &#123; console.log(&apos;onclick&apos;) e.stopPropagation() e.nativeEvent.stopImmediatePropagation()&#125; 以上！"},{"title":"Native ECMAScript modules","date":"2019-05-19","path":"2019/05/19/Native-ECMAScript-modules/","text":"JS modules 是从 ES6 开始引入的模块系统。由于历史原因，我们借助 babel 等编译工具才能提前使用这些特性。好消息是，越来越多的主流浏览器开始支持 ES modules。 到目前为止，大部分主流浏览器都已经支持了原生 JavaScript modules，这意味着我们可以不用打包编译就可以使用 JavaScript modules。 JS 模块化在 JS 发展的历程中，诞生过很多模块化方案，例如 CommonJS, AMD, CMD 等，但没有一个统一的规范。ES6 Modules 的出现，将模块语法统一起来。在 JS modules 中，可以使用 export 和 import 导出导入模块 1234567// hello.jsexport default function() &#123; console.log(&apos;hello world!&apos;)&#125;import sayHello from &apos;./hello/js&apos;sayHello() JS modules 和传统 Javascript 的区别 默认开启严格模式 不支持HTML风格的注释 （&lt;!–注释 –&gt;） 每个模块都有自己的作用域 import export 仅在 JS modules 中使用，传统脚本不能使用 如何在浏览器中使用 JS modules 呢？只需在 script 标签上加上 type=”module”, 浏览器就会自动识别 JS modules。1&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt; 12345678910// hello.jsexport function sayHello() &#123; console.log(&apos;hello world!&apos;);&#125;// inline&lt;script type=&quot;module&quot;&gt;import &#123;sayHello&#125; from &apos;./hello.jssayHello()&lt;/script&gt; 注意：.js 后缀不能省略 import 引入路径支持还不完善12345678910// 支持import &#123;sayHello&#125; from &apos;./hello.js&apos;;import &#123;sayHello&#125; from &apos;../hello.js&apos;;import &#123;sayHello&#125; from &apos;/modules/hello.js&apos;;import &#123;sayHello&#125; from &apos;https://zhihu.com/modules/hello.js&apos;;// 不支持import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;hello.js&apos;;import &#123;sayHello&#125; from &apos;modules/hello.js&apos;; 向后兼容nomodule 属性是为兼容不支持 JS modules 的浏览器， 兼容 JS modules 的浏览器不会执行加了 nomodule 属性的代码。 12&lt;script type=&quot;module&quot; src = &quot;main.js&quot;&gt; &lt;/script&gt;&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt; 异步加载对于带有 type=”module” 的 script， 不论是外部脚本还是内联脚本， 浏览器都会异步加载，不会堵塞浏览器渲染。说到异步加载，有两个属性不得不提。defer 和 async。 12&lt;script src=&quot;main.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; scrip 标签加了 defer 或 async 属性，脚本就会异步加载。传统 JS 中，这两个属性只用于外部脚本，不能用于内联脚本。 两者的区别是，defer 会等到整个页面渲染结束才会执行，async 是脚本加载完成就执行。 JS modules 默认加载行为类似 defer script，也可以使用 async 属性。123456&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt; &lt;/script&gt;&lt;!-- 等同于 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; defer&gt;&lt;/script&gt;&lt;!-- 只要加载完毕，脚本立即执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;foo.js&quot; async&gt;&lt;/script&gt; 预加载浏览器可以预加载，甚至可以预解析，预编译模块及其依赖。 12&lt;link rel=&quot;modulepreload&quot; href=&quot;main.js&quot;&gt;&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 加载过程中的差异 JS modules 只执行一次 1234567&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;!-- main.js 执行多次 --&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;&lt;!-- module.js 只执行一次--&gt; JS modules 及其依赖必须处理跨域问题。传统 JS 中引入其他域的脚本文件是没有跨域问题 12&lt;!-- 通过跨域验证，这段脚本才会执行 --&gt;&lt;script type=&quot;module&quot; src=&quot;https://zhihu.com/modules/hello.js&quot;&gt;&lt;/script&gt; 传统的 script 标签只能在加载外部脚本文件的时候加上 async, 在内联 script 标签加 async 不会生效，但在 JS modules 内联 script 标签上加 async 会生效。 动态导入123456&lt;script type=&quot;module&quot;&gt; (async () =&gt; &#123; const sayHello = await import(&apos;./hello.js&apos;); sayHello() &#125;)();&lt;/script&gt; 局限性只能使用 import，如果一个模块引入几十个包，不借助构建工具，很难做 tree shaking。 HTTP2 的 server push 特性，还不能很好的在高度模块化应用使用，web 服务器和浏览器目前也没有针对这种情况进行优化。 参考：https://jakearchibald.com/2017/es-modules-in-browsers/https://hospodarets.com/native-ecmascript-modules-the-first-overview#nodejs-way-to-mark-the-file-as-a-module"},{"title":"pre 标签文字换行解决方案","date":"2019-02-18","path":"2019/02/18/pre-标签文字换行解决方案/","text":"大家经常遇到这种情况，当一行文字里包含英文字母或数字时会出现不换行局面，一般用 word-wrap:break-word 强制换行就能解决该问题。 但有时候后端返回的数据包含 &lt;pre> 标签的时候，用 word-wrap:break-word 换行是没有效果的。 简单的说就是 &lt;pre> 标签文字无法用 word-wrap:break-word 换行的。 1234567891011&lt;style&gt; pre &#123; display: block; width: 200px; height: 100px; background-color: #ddd; word-wrap: break-word; &#125; &lt;/style&gt;&lt;pre&gt;hexohexohexohexohexohexohexohexohexohexohexohexohexohexohexo&lt;/pre&gt; 解决方法：用 white-space:pre-line 或者 white-space:pre-wrap 就可以轻松解决。"},{"title":"我的博客是怎样炼成的？","date":"2019-02-18","path":"2019/02/18/我的博客是怎样炼成的？/","text":"最近忙里偷闲整了个新博客，原来的博客源码找不到了，也没怎么写东西，就重新开发了一个，其实平时不太喜欢写东西，但感觉记录一下平时之所学还是很有益处的。下面介绍一下自己的建站流程。 这里 技术选型 Hexo + GitHub Hexo 是一款基于 Node.js 的静态博客框架，快速简洁，插件丰富，并且支持 Markdown,开发也很简单，可以生成静态网页托管到 GitHub 或 Heroku 上，我选用的是 GitHub。 申请域名可以在阿里云或腾讯云上申请你的个性域名，使用 GitHub 托管网站，不需要备案，因为托管我们网站的服务器在美国，而且国内备案流程比较繁杂，省去了备案流程也节省了时间。 GitHub 创建个人仓库登录 GitHub 账号，然后创建新仓库，仓库名应该为：用户名.github.io，这是固定写法，比如我的仓库名是 summerwang0915.github.io。 安装 Hexo首先安装 Hexo 命令行工具 1$ npm install hexo-cli -g 然后初始化我们的博客 1$ hexo init blog 为了查看我们的博客雏形，本地启动博客， 123$ cd blog$ npm install$ hexo server 完成后访问 localhost:4000 即可看到我们博客啦。 自定义博客选择一个喜欢的主题，我选择的是 hexo-theme-replica。这个主题是 GitHub 风格的，我稍加修改了下，改成了自己喜欢的样子。 在 _config.yml 文件里修改主题的名字 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-replica 也可以修改博客的基本信息 1234# Sitetitle: 橘大人的 Blogsubtitle:description: 写代码要跟写书法一样写一辈子，喵～ 然后可以修改主题的样式和功能，最后得到你想要的博客的样子。 部署博客链接 GitHub 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:summerwang0915/blog.git branch: master 分别执行 123$ hexo clean$ hexo g$ hexo d 这三条命令是部署网站的命令：hexo g 是 hexo generate 的缩写，用来生成静态文件（public）。hexo d 是 hexo deploy的缩写，用来将生成的静态文件部署到 GitHub 上。hexo clean 用来清除缓存文件和已生成的静态文件。在某些情况下，如果发现对站点的修改不生效，可能需要该命令。 部署完成后，略等几秒后，访问网站地址，即 xxxx.github.io，你会发现博客已经在线上能访问了。 绑定域名如果你想使用个性化域名，则需要在域名代理厂商那里申请。我申请的是腾讯云的域名。域名申请完毕后，进入代腾讯云管理控制台的域名列表，进行解析。 添加两条解析记录,有的时候访问可能会加上 www，其中 185.199.108.153 是 ping 你的 xxxx.github.io 的获得的ip地址。 最后在 source 文件夹下创建 CNAME 文件，把域名填进去。推送到 GitHub 上后，CNAME 文件会显示在根目录下。 大功告成，在浏览器输入你的个性化域名就可以访问你的博客啦。"}]